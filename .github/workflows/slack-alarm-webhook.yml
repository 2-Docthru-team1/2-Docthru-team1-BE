name: Slack Alarm Webhook

on:
  pull_request:
    types: [synchronize]
  pull_request_review:
    types: [submitted]
  pull_request_review_comment:
    types: [created]
  repository_dispatch:
    types: [pr_review_request]
jobs:
  mention_notification:
    name: Mention Notification
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '16'

      - name: Install dependencies
        run: npm install yaml

      - name: Read Slack mapping
        id: slack-mapping
        run: |
          MAPPING=$(cat .github/mention-to-slack.yml)
          echo "mapping<<EOF" >> $GITHUB_OUTPUT
          echo "$MAPPING" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Download previous notification history
        continue-on-error: true
        uses: actions/download-artifact@v3
        with:
          name: notification-history
          path: ./history

      - uses: actions/github-script@v6
        with:
          script: |
            const yaml = require('yaml');
            const fs = require('fs');

            // ì•Œë¦¼ íˆìŠ¤í† ë¦¬ ë¡œë“œ
            let notificationHistory = {};
            try {
              if (fs.existsSync('./history/notifications.json')) {
                notificationHistory = JSON.parse(fs.readFileSync('./history/notifications.json', 'utf8'));
              }
            } catch (error) {
              console.log('No previous notification history found');
            }

            // í˜„ì¬ ì´ë²¤íŠ¸ì˜ í‚¤ ìƒì„±
            const prNumber = context.payload.pull_request?.number || context.payload.client_payload?.pr_url;
            const eventType = context.eventName;
            const eventKey = `${eventType}-${prNumber}`;
            const currentTime = Date.now();

            // 3ë¶„(180000ms) ì´ë‚´ì— ë™ì¼í•œ ì•Œë¦¼ì´ ìˆì—ˆëŠ”ì§€ í™•ì¸
            if (notificationHistory[eventKey] && 
                (currentTime - notificationHistory[eventKey]) < 180000) {
              console.log(`Skipping notification for ${eventKey} - Last notification was sent less than 3 minutes ago`);
              return;
            }


            // ì•Œë¦¼ íƒ€ì… ê²°ì •
            let alarmType = '';
            let headerText = '';

            if (context.eventName === 'repository_dispatch') {
              alarmType = 'ğŸ¯ ìƒˆë¡œìš´ PR ë¦¬ë·° ìš”ì²­';
              headerText = 'ë¦¬ë·°ì–´ê°€ ì„ ì •ë˜ì—ˆìŠµë‹ˆë‹¤';
            } else if (context.eventName === 'pull_request' && context.payload.action === 'synchronize') {
              alarmType = 'ğŸ”„ PR ì—…ë°ì´íŠ¸';
              headerText = 'ìƒˆë¡œìš´ ì»¤ë°‹ì´ í‘¸ì‹œë˜ì—ˆìŠµë‹ˆë‹¤';
            } else if (context.eventName === 'pull_request_review') {
              alarmType = 'âœï¸ ìƒˆë¡œìš´ ë¦¬ë·°';
              headerText = 'ìƒˆë¡œìš´ ë¦¬ë·°ê°€ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤';
            } else if (context.eventName === 'pull_request_review_comment') {
              alarmType = 'ğŸ’¬ ìƒˆë¡œìš´ ë¦¬ë·° ì½”ë©˜íŠ¸';
              headerText = 'ìƒˆë¡œìš´ ë¦¬ë·° ì½”ë©˜íŠ¸ê°€ ì‘ì„±ë˜ì—ˆìŠµë‹ˆë‹¤';
            }

            // PR ì‘ì„±ìì˜ ëŒ“ê¸€ì¸ ê²½ìš° ìŠ¤í‚µ
            if (context.eventName === 'pull_request_review_comment') {
              const commentAuthor = context.payload.comment.user.login;
              const prAuthor = context.payload.pull_request.user.login;
              if (commentAuthor === prAuthor) {
                console.log('PR ì‘ì„±ìì˜ ëŒ“ê¸€ì´ë¯€ë¡œ ì•Œë¦¼ì„ ë³´ë‚´ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                return;
              }
            }

            const mappingFile = fs.readFileSync('.github/mention-to-slack.yml', 'utf8');
            const mapping = yaml.parse(mappingFile);

            let prAuthor, prTitle, prUrl, reviewers;

            // ì´ë²¤íŠ¸ íƒ€ì…ì— ë”°ë¼ ë‹¤ë¥¸ ë°©ì‹ìœ¼ë¡œ ë°ì´í„° ì¶”ì¶œ
            if (context.eventName === 'repository_dispatch') {
              // repository_dispatch ì´ë²¤íŠ¸ ì²˜ë¦¬
              prAuthor = context.payload.client_payload.pr_author;
              prTitle = context.payload.client_payload.pr_title;
              prUrl = context.payload.client_payload.pr_url;
              reviewers = context.payload.client_payload.reviewers.reviewers;
            } else {
              // pull_request ê´€ë ¨ ì´ë²¤íŠ¸ ì²˜ë¦¬
              prAuthor = context.payload.pull_request.user.login;
              prTitle = context.payload.pull_request.title;
              prUrl = context.payload.pull_request.html_url;
              
              // ë¦¬ë·°ì–´ ëª©ë¡ ê°€ì ¸ì˜¤ê¸° (pending ìƒíƒœ ì²´í¬ ì œê±°)
              const { data: reviewData } = await github.rest.pulls.listRequestedReviewers({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.payload.pull_request.number
              });
              reviewers = reviewData.users.map(user => user.login);
            }

            // Slack ID ë³€í™˜
            const authorSlackId = mapping[prAuthor] || prAuthor;
            const formattedAuthor = authorSlackId.startsWith('<@') ? authorSlackId : `<@${authorSlackId}>`;

            const slackReviewers = reviewers
              .map(reviewer => mapping[reviewer] || reviewer)
              .map(id => id.startsWith('<@') ? id : `<@${id}>`)
              .join(', ');

            const message = {
              blocks: [
                {
                  type: "header",
                  text: {
                    type: "plain_text",
                    text: alarmType,
                    emoji: true
                  }
                },
                {
                  type: "section",
                  text: {
                    type: "mrkdwn",
                    text: `*${headerText}*`
                  }
                },
                {
                  type: "section",
                  fields: [
                    {
                      type: "mrkdwn",
                      text: `*ì œëª©:*\n${prTitle}`
                    },
                    {
                      type: "mrkdwn",
                      text: `*ì‘ì„±ì:*\n${formattedAuthor}`
                    }
                  ]
                },
                {
                  type: "section",
                  fields: [
                    {
                      type: "mrkdwn",
                      text: `*ë¦¬ë·°ì–´:*\n${slackReviewers}`
                    }
                  ]
                },
                {
                  type: "section",
                  text: {
                    type: "mrkdwn",
                    text: `*PR ë§í¬:*\n${prUrl}`
                  }
                }
              ]
            };

            // Slackì— ë©”ì‹œì§€ ì „ì†¡
            await fetch(process.env.SLACK_WEBHOOK_URL, {
              method: 'POST',
              headers: {'Content-Type': 'application/json'},
              body: JSON.stringify(message)
            });

            // ì•Œë¦¼ íˆìŠ¤í† ë¦¬ ì—…ë°ì´íŠ¸
            notificationHistory[eventKey] = currentTime;

            // 3ë¶„ì´ ì§€ë‚œ ì´ë²¤íŠ¸ë“¤ì€ ì œê±°
            for (const key in notificationHistory) {
              if (currentTime - notificationHistory[key] > 180000) {
                delete notificationHistory[key];
              }
            }

            // íˆìŠ¤í† ë¦¬ ì €ì¥
            if (!fs.existsSync('./history')) {
              fs.mkdirSync('./history');
            }
            fs.writeFileSync('./history/notifications.json', JSON.stringify(notificationHistory));
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}

      - name: Upload notification history
        uses: actions/upload-artifact@v3
        with:
          name: notification-history
          path: ./history/notifications.json
          retention-days: 1
